<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
 <link rel="icon" href="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS52zXpkvHeVVKTElcquqykAs1EdLJWuKnHeQ&s" sizes="16Ã—16" type="image/png" />    
<title>ã‚½ãƒªãƒ†ã‚£ã‚¢</title>
<style>
  :root{
    --bg-dark:#071322; --bg-dark-2:#042233; --panel: rgba(255,255,255,0.04); --accent:#ffd166; --text-light:#e6f0ff; --card-front:#fff; --card-back-1:#b00000; --card-back-2:#d22; --shadow: 0 10px 30px rgba(2,8,23,0.6);
  }
  [data-theme="light"]{
    --bg-dark:#f5f8ff; --bg-dark-2:#e9eef8; --panel: rgba(0,0,0,0.04); --accent:#2b7cff; --text-light:#052036; --card-back-1:#ffa3a3; --card-back-2:#ff7b7b; --shadow: 0 10px 30px rgba(8,20,40,0.06);
  }

  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:"Noto Sans JP",system-ui,-apple-system,'Segoe UI',Roboto,Helvetica,Arial;background:linear-gradient(180deg,var(--bg-dark),var(--bg-dark-2));color:var(--text-light);-webkit-font-smoothing:antialiased}
  .app{max-width:1100px;margin:12px auto;padding:12px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  h1{font-size:1rem;margin:0}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:var(--panel);border:1px solid rgba(255,255,255,0.04);color:var(--text-light);padding:8px 10px;border-radius:10px;cursor:pointer}
  .status{display:flex;gap:8px;align-items:center}

  /* board */
  .board{display:flex;flex-direction:column;gap:12px}
  .top-row{display:flex;gap:12px;justify-content:space-between;align-items:flex-start}
  .left-top{display:flex;gap:12px}
  .slot{width:84px;height:120px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:var(--shadow);display:flex;align-items:center;justify-content:center;position:relative}
  .slot.empty{border:2px dashed rgba(255,255,255,0.04)}
  .tableau{display:grid;grid-template-columns:repeat(7,1fr);gap:10px;padding-top:10px}
  .column{min-height:160px;padding:6px;border-radius:8px;position:relative}

  /* card */
  .card{width:84px;height:120px;border-radius:10px;position:absolute;touch-action:none;user-select:none;box-shadow:0 8px 22px rgba(0,0,0,0.45);transition:transform .18s ease, top .18s ease, left .18s ease;display:flex;flex-direction:column;justify-content:space-between;background:var(--card-front);overflow:hidden}
  .card .suit{font-size:1rem}
  .card .rank{font-size:0.95rem;font-weight:700}
  .card.face-down{color:transparent}
  .card.red{color:#c62828}
  .card.black{color:#0b2b3a}
  .stack-area{position:relative;min-height:140px}
  .column .card{position:absolute;left:6px}

  /* central suit (large, floating) */
  .card::after{
    content: attr(data-suit);
    position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:2.8rem;opacity:0.22;pointer-events:none;animation:floatSuit 4s ease-in-out infinite;color:var(--suit-color,#111);
  }
  @keyframes floatSuit{0%{transform:translate(-50%,-52%)}50%{transform:translate(-50%,-48%)}100%{transform:translate(-50%,-52%)}}
  .card[data-suit="â™¥"]::after,.card[data-suit="â™¦"]::after{--suit-color:#d22}

  /* back design: red checker (å¸‚æ¾æ¨¡æ§˜) */
  .card.back{
    background-color:var(--card-back-1);
    background-image:
      linear-gradient(45deg, var(--card-back-1) 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, var(--card-back-1) 75%),
      linear-gradient(45deg, transparent 75%, var(--card-back-2) 75%),
      linear-gradient(45deg, var(--card-back-2) 25%, transparent 25%);
    background-size:20px 20px;
    border:2px solid rgba(255,255,255,0.06);
    color:transparent;position:relative;overflow:hidden;
  }
  .card.back::before{content:'â˜…';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:2.2rem;color:rgba(255,255,255,0.45);pointer-events:none}

  /* flip animation */
  .card.flip{
    transition:transform .36s;transform-origin:center;transform-style:preserve-3d;
  }

  /* highlight for hint */
  .hint-highlight{box-shadow:0 0 0 6px rgba(255,213,87,0.18) !important;transform:scale(1.03) !important}

  /* dragging */
  .ghost{opacity:0.95;transform:scale(1.02);z-index:9999}
  .dragging{box-shadow:0 22px 44px rgba(0,0,0,0.6);transform:translateY(-6px) scale(1.02)}

  /* responsive tweaks */
  @media (max-width:720px){
    .slot{width:64px;height:96px}
    .card{width:64px;height:96px}
    .tableau{gap:6px}
    .column{min-height:120px}
  }

  /* victory */
  .victory-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .celebrate{pointer-events:auto;background:linear-gradient(90deg,var(--accent),#ffd6a5);color:#012;border-radius:16px;padding:20px 28px;box-shadow:0 20px 50px rgba(0,0,0,0.3);transform:translateY(-20px);animation:pop 400ms ease forwards}
  @keyframes pop{to{transform:none}}
  .confetti{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none;overflow:hidden}

  /* settings modal */
  .modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:var(--card-front);color:var(--text-light);padding:18px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.35);z-index:2000}

  footer{margin-top:8px;color:rgba(255,255,255,0.6);font-size:0.85rem}
footer {
           padding: 30px;
           text-align: center;
           font-size: 0.85rem;
           color: rgba(255,255,255,0.5);
           border-top: 1px solid rgba(255,255,255,0.1);
           margin-top: 60px;
       }    
</style>
</head>
<body data-theme="dark">
  <div class="app" id="app">
    <header>
      <h1>ã‚½ãƒªãƒ†ã‚£ã‚¢</h1>
      <div class="controls">
        <button id="newBtn">æ–°ã—ã„ã‚²ãƒ¼ãƒ (N)</button>
        <button id="undoBtn">å…ƒã«æˆ»ã™(Z)</button>
        <button id="redealBtn">å†é…å¸ƒ(R)</button>
        <button id="hintBtn">ãƒ’ãƒ³ãƒˆ(H)</button>
        <button id="autoBtn">è‡ªå‹•ã‚½ãƒ¼ãƒˆ(A)</button>
        <button id="settingsBtn">è¨­å®š</button>
        <div class="status" style="margin-left:8px"><div id="moves">Moves: 0</div><div id="time">00:00</div><div id="score" style="margin-left:8px">Score: 0</div></div>
      </div>
    </header>

    <main class="board" id="board">
      <div class="top-row">
        <div class="left-top" style="display:flex;gap:10px;">
          <div class="slot" id="stock" title="å±±æœ­"></div>
          <div class="slot" id="waste" title="æ¨ã¦æœ­"></div>
        </div>
        <div style="display:flex;gap:10px;">
          <div class="slot empty" id="f0" data-foundation="0"></div>
          <div class="slot empty" id="f1" data-foundation="1"></div>
          <div class="slot empty" id="f2" data-foundation="2"></div>
          <div class="slot empty" id="f3" data-foundation="3"></div>
        </div>
      </div>

      <section class="tableau" id="tableau">
        <div class="column" data-col="0"></div>
        <div class="column" data-col="1"></div>
        <div class="column" data-col="2"></div>
        <div class="column" data-col="3"></div>
        <div class="column" data-col="4"></div>
        <div class="column" data-col="5"></div>
        <div class="column" data-col="6"></div>
      </section>

    </main>
    <footer>ã‚¹ãƒãƒ›ãƒ»PCä¸¡å¯¾å¿œã€‚ã‚¿ãƒƒãƒ—ã§è‡ªå‹•é…ç½®ã€ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã€‚è¨­å®šã§ã‚ãã‚Šæ•°ã¨ãƒ†ãƒ¼ãƒã‚’å¤‰æ›´ã§ãã¾ã™ã€‚</footer>
  </div>

  <div id="victory" class="victory-overlay" style="display:none">
    <div class="celebrate">
      <h2>ãŠã‚ã§ã¨ã†ï¼ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ ğŸ‰</h2>
      <div style="margin-top:8px;display:flex;gap:8px;justify-content:center"><button id="newAfterWin">æ–°ã—ã„ã‚²ãƒ¼ãƒ </button><button id="closeWin">é–‰ã˜ã‚‹</button></div>
    </div>
  </div>
  <div id="confetti" class="confetti" style="display:none"></div>

  <div id="settingsModal" class="modal" style="display:none">
    <h3>è¨­å®š</h3>
    <div style="display:flex;gap:8px;align-items:center;margin-top:8px"><label>ãƒ†ãƒ¼ãƒ:</label><select id="themeSelect"><option value="dark">ãƒ€ãƒ¼ã‚¯</option><option value="light">ãƒ©ã‚¤ãƒˆ</option></select></div>
    <div style="display:flex;gap:8px;align-items:center;margin-top:8px"><label>ã‚ãã‚Šæ•°:</label><select id="drawSelect"><option value="1">1æš</option><option value="3">3æš</option></select></div>
    <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end"><button id="saveSettings">ä¿å­˜</button><button id="cancelSettings">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button></div>
  </div>

  <footer>
       Â© 2025 STAR CORPORATION - All Rights Reserved.
   </footer>

<script>
(function () {
  'use strict';

  // === constants ===
  const SUITS = ['â™ ','â™¥','â™¦','â™£'];
  const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

  // === state ===
  let deck = [];
  let stock = [];      // faceDown cards in stock (objects)
  let waste = [];      // faceUp waste (objects)
  let foundations = [[],[],[],[]];
  let columns = [[],[],[],[],[],[],[]];

  let moves = 0;
  let seconds = 0;
  let timerInterval = null;
  let history = [];
  let drawCount = 1;

  let score = 0;

  // === DOM refs ===
  const stockEl = document.getElementById('stock');
  const wasteEl = document.getElementById('waste');
  const tableau = document.getElementById('tableau');
  const movesEl = document.getElementById('moves');
  const timeEl = document.getElementById('time');
  const scoreEl = document.getElementById('score');
  const hintBtn = document.getElementById('hintBtn');
  const autoBtn = document.getElementById('autoBtn');

  // === helpers ===
  function makeDeck() {
    const d = [];
    SUITS.forEach(function (s, i) {
      RANKS.forEach(function (r, ri) {
        d.push({ suit: s, rank: r, value: ri + 1, suitIndex: i, id: s + r + Math.random().toString(36).slice(2,8) });
      });
    });
    return d;
  }

  function shuffleArray(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
  }

  function saveHistory() {
    try {
      history.push(JSON.stringify({ stock: stock, waste: waste, foundations: foundations, columns: columns, moves: moves, seconds: seconds, score: score }));
      if (history.length > 250) history.shift();
    } catch (err) {
      // ignore
    }
  }

  function undo() {
    if (!history.length) return;
    const prev = JSON.parse(history.pop());
    stock = prev.stock;
    waste = prev.waste;
    foundations = prev.foundations;
    columns = prev.columns;
    moves = prev.moves;
    seconds = prev.seconds;
    score = prev.score || 0;
    render();
    updateStatus();
  }

  function startTimer() {
    stopTimer();
    timerInterval = setInterval(function () { seconds++; updateStatus(); }, 1000);
  }

  function stopTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  }

  function updateStatus() {
    movesEl.textContent = 'Moves: ' + moves;
    scoreEl.textContent = 'Score: ' + score;
    const m = String(Math.floor(seconds / 60)).padStart(2, '0');
    const s = String(seconds % 60).padStart(2, '0');
    timeEl.textContent = m + ':' + s;
  }

  // === game start / deal ===
  function newGame() {
    deck = makeDeck();
    shuffleArray(deck);
    // convert deck into objects for stock
    stock = deck.slice().map(c => Object.assign({}, c, { faceUp: false }));
    waste = [];
    foundations = [[],[],[],[]];
    columns = [[],[],[],[],[],[],[]];
    moves = 0;
    seconds = 0;
    history = [];
    score = 0;

    // deal to columns (Klondike)
    for (let i = 0; i < 7; i++) {
      for (let j = 0; j <= i; j++) {
        const card = stock.pop();
        const faceUp = j === i;
        columns[i].push(Object.assign({}, card, { faceUp: faceUp }));
      }
    }

    saveHistory();
    render();
    updateStatus();
    startTimer();
  }

  function clearElement(el) {
    while (el.firstChild) el.removeChild(el.firstChild);
  }

  // create DOM card from card object
  function renderCard(card) {
    const c = document.createElement('div');
    c.className = 'card';
    if (!card.faceUp) c.classList.add('back');
    const color = (card.suit === 'â™¥' || card.suit === 'â™¦') ? 'red' : 'black';
    c.classList.add(color);
    c.dataset.id = card.id;
    c.dataset.suit = card.suit;
    c.dataset.rank = card.rank;
    c.dataset.value = card.value;

    if (card.faceUp) {
      const top = document.createElement('div');
      top.style.padding = '6px';
      top.innerHTML = '<div class="rank">' + card.rank + '</div><div class="suit">' + card.suit + '</div>';
      const bot = document.createElement('div');
      bot.style.padding = '6px';
      bot.style.transform = 'rotate(180deg)';
      bot.innerHTML = '<div class="rank">' + card.rank + '</div><div class="suit">' + card.suit + '</div>';
      c.appendChild(top);
      c.appendChild(bot);
    }

    // pointer events attached elsewhere via observer (but safe to attach)
    c.addEventListener('pointerdown', onPointerDown);
    c.addEventListener('click', onCardClick);
    return c;
  }

  // render entire board
  function render() {
    clearElement(stockEl);
    clearElement(wasteEl);
    for (let i = 0; i < 4; i++) {
      const f = document.getElementById('f' + i);
      clearElement(f);
      if (foundations[i].length) {
        f.appendChild(renderCard(foundations[i][foundations[i].length - 1]));
      }
    }

    if (stock.length) {
      // Show stack as overlapped backs
      const count = Math.min(stock.length, 6);
      for (let i = 0; i < count; i++) {
        const back = document.createElement('div');
        back.className = 'card back';
        back.style.position = 'absolute';
        back.style.left = (i * 3) + 'px';
        back.style.top = (i * 2) + 'px';
        back.style.width = '70%';
        back.style.height = '80%';
        back.style.transform = 'translate(0,0)';
        stockEl.appendChild(back);
      }
      stockEl.classList.remove('empty');
    } else {
      stockEl.classList.add('empty');
    }

    if (waste.length) {
      wasteEl.appendChild(renderCard(waste[waste.length - 1]));
    }

    const cols = tableau.querySelectorAll('.column');
    cols.forEach(function (col, i) {
      clearElement(col);
      const area = document.createElement('div');
      area.className = 'stack-area';
      area.style.minHeight = '140px';
      col.appendChild(area);
      columns[i].forEach(function (card, idx) {
        const cardEl = renderCard(card);
        cardEl.style.top = (idx * 26) + 'px';
        cardEl.style.left = '6px';
        cardEl.dataset.col = i;
        cardEl.dataset.idx = idx;
        area.appendChild(cardEl);
      });
    });

    checkWin(false);
    updateStatus();
  }

  // find card object location
  function findCardById(id) {
    for (let col of columns) {
      for (let c of col) {
        if (c.id === id) return { where: 'col', col: col, card: c };
      }
    }
    for (let fi = 0; fi < foundations.length; fi++) {
      for (let c of foundations[fi]) {
        if (c.id === id) return { where: 'found', foundIndex: fi, found: foundations[fi], card: c };
      }
    }
    for (let c of waste) {
      if (c.id === id) return { where: 'waste', card: c };
    }
    for (let c of stock) {
      if (c.id === id) return { where: 'stock', card: c };
    }
    return null;
  }

  function canPlaceOnColumn(card, destCol) {
    if (!destCol.length) return card.rank === 'K';
    const top = destCol[destCol.length - 1];
    const topColor = (top.suit === 'â™¥' || top.suit === 'â™¦') ? 'red' : 'black';
    const cardColor = (card.suit === 'â™¥' || card.suit === 'â™¦') ? 'red' : 'black';
    return top.value === card.value + 1 && topColor !== cardColor;
  }

  function canPlaceOnFoundation(card, fi) {
    const f = foundations[fi];
    if (!f.length) return card.rank === 'A';
    const top = f[f.length - 1];
    return top.suit === card.suit && card.value === top.value + 1;
  }

  // click handlers (tap)
  function onCardClick(e) {
    e.stopPropagation();
    const el = e.currentTarget;
    const id = el.dataset.id;
    const found = findCardById(id);
    if (!found) return;

    // flip face-down last card in column
    if (found.where === 'col') {
      const col = found.col;
      const card = found.card;
      const idx = col.indexOf(card);
      if (!card.faceUp && idx === col.length - 1) {
        saveHistory();
        card.faceUp = true;
        moves++;
        score += 5; // reward for flipping
        updateStatus();
        render();
        return;
      }
    }

    if (found.where === 'stock') {
      saveHistory();
      drawFromStock();
      return;
    }

    if (found.where === 'waste' || found.where === 'col') {
      const card = (found.where === 'waste') ? waste[waste.length - 1] : found.card;
      // try foundation first
      for (let i = 0; i < 4; i++) {
        if (canPlaceOnFoundation(card, i)) {
          saveHistory();
          if (found.where === 'waste') waste.pop();
          else {
            const col = found.col;
            col.splice(col.indexOf(card), 1);
            if (col.length && !col[col.length - 1].faceUp) {
              col[col.length - 1].faceUp = true;
              score += 5;
            }
          }
          foundations[i].push(card);
          moves++;
          score += 10;
          updateStatus();
          render();
          return;
        }
      }
      // then try columns
      for (let ci = 0; ci < 7; ci++) {
        if (canPlaceOnColumn(card, columns[ci])) {
          saveHistory();
          if (found.where === 'waste') waste.pop();
          else {
            const col = found.col;
            col.splice(col.indexOf(card), 1);
            if (col.length && !col[col.length - 1].faceUp) {
              col[col.length - 1].faceUp = true;
              score += 5;
            }
          }
          columns[ci].push(card);
          moves++;
          score += 5;
          updateStatus();
          render();
          return;
        }
      }
    }
  }

  // draw from stock
  function drawFromStock() {
    if (stock.length) {
      for (let i = 0; i < drawCount && stock.length; i++) {
        const c = stock.pop();
        c.faceUp = true;
        waste.push(c);
      }
      moves++;
      score -= 1;
      updateStatus();
      render();
    } else {
      // recycle waste -> stock (faceDown)
      saveHistory();
      stock = waste.splice(0).map(function (c) { return Object.assign({}, c, { faceUp: false }); });
      stock.reverse();
      moves++;
      updateStatus();
      render();
    }
  }

  // HINT utilities
  function clearHints() {
    document.querySelectorAll('.hint-highlight').forEach(function (el) { el.classList.remove('hint-highlight'); });
  }

  function highlightIds(ids) {
    ids.forEach(function (id) {
      const el = document.querySelector('[data-id="' + id + '"]');
      if (el) el.classList.add('hint-highlight');
    });
  }

  function findAnyMove() {
    if (waste.length) {
      const c = waste[waste.length - 1];
      for (let i = 0; i < 4; i++) if (canPlaceOnFoundation(c, i)) return { sourceIds: [c.id] };
      for (let ci = 0; ci < 7; ci++) if (canPlaceOnColumn(c, columns[ci])) return { sourceIds: [c.id] };
    }

    for (let ci = 0; ci < 7; ci++) {
      const col = columns[ci];
      for (let i = 0; i < col.length; i++) {
        const card = col[i];
        if (!card.faceUp) continue;
        for (let fi = 0; fi < 4; fi++) if (canPlaceOnFoundation(card, fi)) return { sourceIds: [card.id] };
        const stack = col.slice(i);
        const top = stack[0];
        for (let dj = 0; dj < 7; dj++) {
          if (dj === ci) continue;
          if (canPlaceOnColumn(top, columns[dj])) return { sourceIds: stack.map(function (c) { return c.id; }) };
        }
      }
    }
    return null;
  }

  function hint() {
    clearHints();
    const h = findAnyMove();
    if (!h) {
      hintBtn.textContent = 'ãƒ’ãƒ³ãƒˆ (ãªã—)';
      setTimeout(function () { hintBtn.textContent = 'ãƒ’ãƒ³ãƒˆ'; }, 1200);
      return;
    }
    highlightIds(h.sourceIds);
    setTimeout(clearHints, 2500);
  }

  // auto sort to foundations
  function autoSort() {
    var moved;
    do {
      moved = false;
      if (waste.length) {
        const c = waste[waste.length - 1];
        for (let i = 0; i < 4; i++) {
          if (canPlaceOnFoundation(c, i)) {
            saveHistory();
            waste.pop();
            foundations[i].push(c);
            moves++;
            score += 10;
            moved = true;
            break;
          }
        }
      }
      if (moved) continue;
      for (let ci = 0; ci < 7 && !moved; ci++) {
        const col = columns[ci];
        if (!col.length) continue;
        const top = col[col.length - 1];
        if (top.faceUp) {
          for (let fi = 0; fi < 4; fi++) {
            if (canPlaceOnFoundation(top, fi)) {
              saveHistory();
              col.pop();
              foundations[fi].push(top);
              if (col.length && !col[col.length - 1].faceUp) {
                col[col.length - 1].faceUp = true;
                score += 5;
              }
              moves++;
              score += 10;
              moved = true;
              break;
            }
          }
        }
      }
    } while (moved);
    updateStatus();
    render();
  }

  // win check
  function checkWin(show) {
    if (show === undefined) show = true;
    const total = foundations.reduce(function (s, f) { return s + f.length; }, 0);
    if (total === 52) {
      if (show) triggerWin();
      return true;
    }
    return false;
  }

  function triggerWin() {
    var el = document.getElementById('victory');
    if (el) el.style.display = 'flex';
    launchConfetti();
    stopTimer();
  }

  function closeWin() {
    var el = document.getElementById('victory');
    if (el) el.style.display = 'none';
    stopConfetti();
  }

  function launchConfetti() {
    var el = document.getElementById('confetti');
    if (!el) return;
    el.innerHTML = '';
    el.style.display = 'block';
    var colors = ['#ffd166', '#06d6a0', '#f94144', '#8ecae6', '#ffb4a2'];
    for (var i = 0; i < 120; i++) {
      var c = document.createElement('i');
      c.style.position = 'absolute';
      c.style.left = (Math.random() * 100) + '%';
      c.style.top = (Math.random() * -20) + 'vh';
      c.style.width = '10px';
      c.style.height = '18px';
      c.style.background = colors[i % colors.length];
      c.style.opacity = (Math.random() * 0.9 + 0.2).toString();
      c.style.transform = 'rotate(' + (Math.random() * 360) + 'deg)';
      c.style.animation = 'fall ' + (2 + Math.random() * 2) + 's linear forwards';
      c.style.animationDelay = (Math.random() * 400) + 'ms';
      el.appendChild(c);
    }
    setTimeout(stopConfetti, 5000);
  }

  function stopConfetti() {
    var el = document.getElementById('confetti');
    if (!el) return;
    el.style.display = 'none';
    el.innerHTML = '';
  }

  // Drag & Tap system (simplified)
  var dragging = null;
  var dragClone = null;

  function onPointerDown(ev) {
    ev.preventDefault();
    ev.stopPropagation();
    var node = ev.currentTarget;
    var id = node.dataset.id;
    var found = findCardById(id);
    if (!found) return;
    var card = (found.where === 'col') ? found.card : (found.where === 'waste' ? found.card : null);
    if (!card || !card.faceUp) return;

    var movingStack = [];
    if (found.where === 'col') {
      var col = found.col;
      var pos = col.indexOf(card);
      for (var i = pos; i < col.length; i++) movingStack.push(col[i]);
    } else {
      movingStack.push(card);
    }

    dragging = { source: found, cards: movingStack };

    dragClone = document.createElement('div');
    dragClone.style.position = 'fixed';
    dragClone.style.zIndex = '9999';
    dragClone.style.left = ev.clientX + 'px';
    dragClone.style.top = ev.clientY + 'px';
    dragClone.style.transform = 'translate(-30px,-40px)';
    dragClone.style.pointerEvents = 'none';
    dragClone.className = 'ghost';

    movingStack.forEach(function (c, idx) {
      var ce = renderCard(c);
      ce.style.position = 'relative';
      ce.style.top = (idx * 26) + 'px';
      ce.style.left = '0';
      ce.style.margin = '0';
      ce.style.boxShadow = '0 12px 24px rgba(0,0,0,0.45)';
      dragClone.appendChild(ce);
    });

    document.body.appendChild(dragClone);

    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
  }

  function onPointerMove(ev) {
    if (!dragClone) return;
    dragClone.style.left = ev.clientX + 'px';
    dragClone.style.top = ev.clientY + 'px';
  }

  function onPointerUp(ev) {
    window.removeEventListener('pointermove', onPointerMove);
    window.removeEventListener('pointerup', onPointerUp);
    if (!dragging) return;

    var pt = document.elementFromPoint(ev.clientX, ev.clientY);
    var dropped = false;
    var f = pt.closest('[data-foundation]');
    if (f) {
      var fi = Number(f.dataset.foundation);
      var card = dragging.cards[0];
      if (canPlaceOnFoundation(card, fi)) {
        saveHistory();
        if (dragging.source.where === 'col') {
          var col = dragging.source.col;
          var pos = col.indexOf(card);
          var moving = col.splice(pos);
          foundations[fi] = foundations[fi].concat(moving);
          if (col.length && !col[col.length - 1].faceUp) col[col.length - 1].faceUp = true;
        } else if (dragging.source.where === 'waste') {
          waste.pop();
          foundations[fi].push(card);
        }
        moves++;
        score += 10;
        updateStatus();
        render();
        dropped = true;
      }
    }

    if (!dropped) {
      var colEl = pt.closest('.column');
      if (colEl) {
        var ci = Number(colEl.dataset.col);
        var dest = columns[ci];
        var movingTop = dragging.cards[0];
        if (canPlaceOnColumn(movingTop, dest)) {
          saveHistory();
          if (dragging.source.where === 'col') {
            var col2 = dragging.source.col;
            var pos2 = col2.indexOf(movingTop);
            var moving2 = col2.splice(pos2);
            columns[ci] = columns[ci].concat(moving2);
            if (col2.length && !col2[col2.length - 1].faceUp) col2[col2.length - 1].faceUp = true;
          } else if (dragging.source.where === 'waste') {
            var c = waste.pop();
            columns[ci].push(c);
          }
          moves++;
          score += 5;
          updateStatus();
          render();
          dropped = true;
        } else if (!dest.length && movingTop.rank === 'K') {
          saveHistory();
          if (dragging.source.where === 'col') {
            var col3 = dragging.source.col;
            var pos3 = col3.indexOf(movingTop);
            var moving3 = col3.splice(pos3);
            columns[ci] = columns[ci].concat(moving3);
            if (col3.length && !col3[col3.length - 1].faceUp) col3[col3.length - 1].faceUp = true;
          } else {
            columns[ci].push(waste.pop());
          }
          moves++;
          score += 5;
          updateStatus();
          render();
          dropped = true;
        }
      }
    }

    if (!dropped) render();

    dragging = null;
    if (dragClone && dragClone.parentNode) dragClone.parentNode.removeChild(dragClone);
    dragClone = null;
  }

  // attach events
  stockEl.addEventListener('click', function () { saveHistory(); drawFromStock(); });
  document.getElementById('newBtn').addEventListener('click', function () { newGame(); });
  document.getElementById('undoBtn').addEventListener('click', function () { undo(); });
  document.getElementById('redealBtn').addEventListener('click', function () { redealAll(); });
  hintBtn.addEventListener('click', function () { hint(); });
  autoBtn.addEventListener('click', function () { autoSort(); });

  // settings modal
  var settingsModal = document.getElementById('settingsModal');
  var settingsBtn = document.getElementById('settingsBtn');
  var themeSelect = document.getElementById('themeSelect');
  var drawSelect = document.getElementById('drawSelect');
  var saveSettings = document.getElementById('saveSettings');
  var cancelSettings = document.getElementById('cancelSettings');

  settingsBtn.addEventListener('click', function () {
    settingsModal.style.display = 'block';
    themeSelect.value = document.body.getAttribute('data-theme') || 'dark';
    drawSelect.value = String(drawCount);
  });
  cancelSettings.addEventListener('click', function () { settingsModal.style.display = 'none'; });
  saveSettings.addEventListener('click', function () {
    document.body.setAttribute('data-theme', themeSelect.value);
    drawCount = Number(drawSelect.value);
    settingsModal.style.display = 'none';
    render();
  });

  document.getElementById('newAfterWin').addEventListener('click', function () { closeWin(); newGame(); });
  document.getElementById('closeWin').addEventListener('click', function () { closeWin(); });

  var styleHint = document.createElement('style');
  styleHint.innerHTML = '.hint-highlight{box-shadow:0 0 0 6px rgba(255,213,87,0.18) !important;transform:scale(1.03) !important}';
  document.head.appendChild(styleHint);

  // MutationObserver to ensure pointer events on new cards
  var observer = new MutationObserver(function () {
    document.querySelectorAll('.card').forEach(function (c) {
      if (!c._hasPointer) {
        c._hasPointer = true;
        c.addEventListener('pointerdown', onPointerDown);
      }
    });
  });
  observer.observe(document.body, { childList: true, subtree: true });

  // --- Redeal: collect all cards, shuffle, redeal to tableau ---
  function redealAll() {
    // Gather all card objects
    const all = [];
    // columns
    for (let i = 0; i < 7; i++) {
      while (columns[i].length) {
        all.push(columns[i].pop());
      }
    }
    // foundations
    for (let i = 0; i < 4; i++) {
      while (foundations[i].length) {
        all.push(foundations[i].pop());
      }
    }
    // waste
    while (waste.length) all.push(waste.pop());
    // stock
    while (stock.length) all.push(stock.pop());

    // Shuffle gathered cards
    shuffleArray(all);

    // Reset state and redeal: put into stock then deal to tableau
    stock = all.slice();
    columns = [[],[],[],[],[],[],[]];
    // deal like newGame
    for (let i = 0; i < 7; i++) {
      for (let j = 0; j <= i; j++) {
        const card = stock.pop();
        const faceUp = j === i;
        columns[i].push(Object.assign({}, card, { faceUp: faceUp }));
      }
    }

    // reset moves/time? keep moves but reset timer/score adjustments
    moves = 0;
    seconds = 0;
    score = 0;
    history = [];
    saveHistory();
    render();
    updateStatus();
    startTimer();
  }

  // --- Keyboard controls ---
  // Z: undo, R: redeal, N: new, H: hint, A: auto
  document.addEventListener('keydown', function (e) {
    if (e.key === 'z' || e.key === 'Z') {
      undo();
    } else if (e.key === 'r' || e.key === 'R') {
      redealAll();
    } else if (e.key === 'n' || e.key === 'N') {
      newGame();
    } else if (e.key === 'h' || e.key === 'H') {
      hint();
    } else if (e.key === 'a' || e.key === 'A') {
      autoSort();
    } else if (e.key === ' ') {
      // space = draw
      e.preventDefault();
      saveHistory();
      drawFromStock();
    }
  });

  // start
  newGame();

})();

// --- Auto vertical stacking for tableau columns (visual) ---
(function(){
  const STACK_GAP = 26; // px per card
  const board = document.getElementById('board');

  const stackCards = () => {
    const piles = board.querySelectorAll('.column');
    piles.forEach(pile => {
      const cards = Array.from(pile.querySelectorAll('.card'));
      cards.forEach((card, i) => {
        card.style.top = (i * STACK_GAP) + 'px';
      });
    });
  };

  const obs = new MutationObserver(stackCards);
  obs.observe(board, { childList: true, subtree: true });
  window.addEventListener('load', stackCards);
})();
</script>
</body>
</html>
